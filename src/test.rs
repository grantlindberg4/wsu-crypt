use super::*;

#[test]
fn test_whitening_stage() {
    let key: Vec<u8> = vec![0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89];
    let plaintext: Vec<u8> = vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

    let results = whiten::whiten_input(&key, &plaintext);
    assert!(results == [0xaaee, 0xaa66, 0xaaee, 0xaa66]);
}

#[test]
fn test_g_function() {
    let r0 = 0xaaee;
    let subkeys = vec![
        0x13, 0x9e, 0x2b, 0x34, 0x35, 0xe2,
        0xb3, 0x45, 0x57, 0x26, 0x3c, 0x56
    ];
    let g1 = (r0 >> 8) as u8;
    assert!(g1 == 0xaa);
    let g2 = r0 as u8;
    assert!(g2 == 0xee);
    
    let g3 = crypt::get_f_table_value(g2 ^ subkeys[0]) ^ g1;
    assert!(g3 == 0xf3);
    let g4 = crypt::get_f_table_value(g3 ^ subkeys[1]) ^ g2;
    assert!(g4 == 0x76);
    let g5 = crypt::get_f_table_value(g4 ^ subkeys[2]) ^ g3;
    assert!(g5 == 0xf8);
    let g6 = crypt::get_f_table_value(g5 ^ subkeys[3]) ^ g4;
    assert!(g6 == 0x89);
}

#[test]
fn test_get_values_from_f_table() {
    let index: u8 = 0x7a;
    let row = (index >> 4) as usize;
    let col = (index.rotate_right(4) >> 4) as usize;
    assert!(row == 7);
    assert!(col == 10);
    assert!(crypt::F_TABLE[row*crypt::ROW_LEN + col] == 0xd6);

    assert!(crypt::get_f_table_value(0x7a) == 0xd6);
}

#[test]
fn test_f_function() {
    let r0 = 0xaaee;
    let r1 = 0xaa66;
    let subkeys = vec![
        0x13, 0x9e, 0x2b, 0x34, 0x35, 0xe2,
        0xb3, 0x45, 0x57, 0x26, 0x3c, 0x56
    ];

    let t0 = crypt::g(r0, &subkeys[0..4], 0);
    assert!(t0 == 0xf889);
    let t1 = crypt::g(r1, &subkeys[4..8], 0);
    assert!(t1 == 0x7781);

    let sum = t0 as u32 + 2*t1 as u32 + convert_types::to_u16_block(&subkeys[8], &subkeys[9]) as u32; 
    let f0 = (sum % 2u32.pow(16)) as u16;
    assert!(f0 == 0x3eb1);

    let sum = 2*t0 as u32 + t1 as u32 + convert_types::to_u16_block(&subkeys[10], &subkeys[11]) as u32;
    let f1 = (sum % 2u32.pow(16)) as u16;
    assert!(f1 == 0xa4e9);
}

#[test]
fn test_subkey_generation_for_encrypt() {
    let expected: Vec<Vec<u8>> = vec![
        vec![0x13,  0x9e,  0x2b,  0x34,  0x35,  0xe2,  0xb3,  0x45,  0x57,  0x26,  0x3c,  0x56],
        vec![0x68,  0x48,  0x80,  0xef,  0x8a,  0x8d,  0x09,  0xf0,  0xac,  0xd1,  0x91,  0x01],
        vec![0xde,  0x37,  0x5e,  0x9a,  0xe0,  0x7b,  0xe6,  0xab,  0x02,  0xbc,  0x6f,  0xbc],
        vec![0x35,  0xe2,  0xb3,  0x45,  0x57,  0x26,  0x3c,  0x56,  0x79,  0x6a,  0xc4,  0x67],
        vec![0x8a,  0x8d,  0x09,  0xf0,  0xac,  0xd1,  0x91,  0x01,  0xcf,  0x15,  0x1a,  0x12],
        vec![0xe0,  0x7b,  0xe6,  0xab,  0x02,  0xbc,  0x6f,  0xbc,  0x24,  0xc0,  0xf7,  0xcd],
        vec![0x57,  0x26,  0x3c,  0x56,  0x79,  0x6a,  0xc4,  0x67,  0x9b,  0xaf,  0x4d,  0x78],
        vec![0xac,  0xd1,  0x91,  0x01,  0xcf,  0x15,  0x1a,  0x12,  0xf1,  0x59,  0xa2,  0x23],
        vec![0x02,  0xbc,  0x6f,  0xbc,  0x24,  0xc0,  0xf7,  0xcd,  0x46,  0x04,  0x78,  0xde],
        vec![0x79,  0x6a,  0xc4,  0x67,  0x9b,  0xaf,  0x4d,  0x78,  0xbd,  0xf3,  0xd5,  0x89],
        vec![0xcf,  0x15,  0x1a,  0x12,  0xf1,  0x59,  0xa2,  0x23,  0x13,  0x9e,  0x2b,  0x34],
        vec![0x24,  0xc0,  0xf7,  0xcd,  0x46,  0x04,  0x78,  0xde,  0x68,  0x48,  0x80,  0xef],
        vec![0x9b,  0xaf,  0x4d,  0x78,  0xbd,  0xf3,  0xd5,  0x89,  0xde,  0x37,  0x5e,  0x9a],
        vec![0xf1,  0x59,  0xa2,  0x23,  0x13,  0x9e,  0x2b,  0x34,  0x35,  0xe2,  0xb3,  0x45],
        vec![0x46,  0x04,  0x78,  0xde,  0x68,  0x48,  0x80,  0xef,  0x8a,  0x8d,  0x09,  0xf0],
        vec![0xbd,  0xf3,  0xd5,  0x89,  0xde,  0x37,  0x5e,  0x9a,  0xe0,  0x7b,  0xe6,  0xab],
    ];

    let mut key_block = 0xabcdef0123456789;

    let mut actual: Vec<Vec<u8>> = vec![];

    for r in 0..crypt::NUM_ROUNDS {
        let subkeys = subkey_gen::generate_subkeys_for_encrypt(&mut key_block, r);
        assert!(subkeys.len() == crypt::COL_LEN);
        actual.push(subkeys);
    }

    assert!(actual == expected);
}

#[test]
fn test_subkey_generation_for_decrypt() {
    let expected: Vec<Vec<u8>> = vec![
        vec![0xbd,  0xf3,  0xd5,  0x89,  0xde,  0x37,  0x5e,  0x9a,  0xe0,  0x7b,  0xe6,  0xab],
        vec![0x46,  0x04,  0x78,  0xde,  0x68,  0x48,  0x80,  0xef,  0x8a,  0x8d,  0x09,  0xf0],
        vec![0xf1,  0x59,  0xa2,  0x23,  0x13,  0x9e,  0x2b,  0x34,  0x35,  0xe2,  0xb3,  0x45],
        vec![0x9b,  0xaf,  0x4d,  0x78,  0xbd,  0xf3,  0xd5,  0x89,  0xde,  0x37,  0x5e,  0x9a],
        vec![0x24,  0xc0,  0xf7,  0xcd,  0x46,  0x04,  0x78,  0xde,  0x68,  0x48,  0x80,  0xef],
        vec![0xcf,  0x15,  0x1a,  0x12,  0xf1,  0x59,  0xa2,  0x23,  0x13,  0x9e,  0x2b,  0x34],
        vec![0x79,  0x6a,  0xc4,  0x67,  0x9b,  0xaf,  0x4d,  0x78,  0xbd,  0xf3,  0xd5,  0x89],
        vec![0x02,  0xbc,  0x6f,  0xbc,  0x24,  0xc0,  0xf7,  0xcd,  0x46,  0x04,  0x78,  0xde],
        vec![0xac,  0xd1,  0x91,  0x01,  0xcf,  0x15,  0x1a,  0x12,  0xf1,  0x59,  0xa2,  0x23],
        vec![0x57,  0x26,  0x3c,  0x56,  0x79,  0x6a,  0xc4,  0x67,  0x9b,  0xaf,  0x4d,  0x78],
        vec![0xe0,  0x7b,  0xe6,  0xab,  0x02,  0xbc,  0x6f,  0xbc,  0x24,  0xc0,  0xf7,  0xcd],
        vec![0x8a,  0x8d,  0x09,  0xf0,  0xac,  0xd1,  0x91,  0x01,  0xcf,  0x15,  0x1a,  0x12],
        vec![0x35,  0xe2,  0xb3,  0x45,  0x57,  0x26,  0x3c,  0x56,  0x79,  0x6a,  0xc4,  0x67],
        vec![0xde,  0x37,  0x5e,  0x9a,  0xe0,  0x7b,  0xe6,  0xab,  0x02,  0xbc,  0x6f,  0xbc],
        vec![0x68,  0x48,  0x80,  0xef,  0x8a,  0x8d,  0x09,  0xf0,  0xac,  0xd1,  0x91,  0x01],
        vec![0x13,  0x9e,  0x2b,  0x34,  0x35,  0xe2,  0xb3,  0x45,  0x57,  0x26,  0x3c,  0x56],
    ];

    let mut key_block: u64 = 0xabcdef0123456789;

    let mut actual: Vec<Vec<u8>> = vec![];

    for r in 0..crypt::NUM_ROUNDS {
        let mut subkeys = subkey_gen::generate_subkeys_for_decrypt(&mut key_block, r);
        subkeys.reverse();
        assert!(subkeys.len() == crypt::COL_LEN);
        actual.push(subkeys);
    }

    assert!(actual == expected);
}

#[test]
fn test_block_creation() {
    let mut r0 = 0xaaee;
    let mut r1 = 0xaa66;
    let mut r2 = 0xaaee;
    let mut r3 = 0xaa66;
    let mut key_block = 0xabcdef0123456789;

    let subkeys = subkey_gen::generate_subkeys_for_encrypt(&mut key_block, 0);
    let (f0, f1) = crypt::f(r0, r1, &subkeys, 0);
    assert!(f0 == 0x3eb1);
    assert!(f1 == 0xa4e9);
    let temp_r2 = r2;
    let temp_r3 = r3;
    r2 = r0;
    r3 = r1;
    r0 = temp_r2 ^ f0 as u16;
    r1 = temp_r3 ^ f1 as u16;

    let block = convert_types::to_u32_vec(&vec![r0, r1, r2, r3]);
    let block = ((block[0] as u64) << 32) | block[1] as u64;

    assert!(block == 0x945f0e8faaeeaa66);
}

#[test]
fn test_subkey_generation_in_f_function() {
    let expected: Vec<u64> = vec![
        0x945f0e8faaeeaa66,
        0x24c7cb70945f0e8f,
        0x99efc5d324c7cb70,
        0xe0562f3499efc5d3,
        0x708dbb8ce0562f34,
        0xb3a5bb1c708dbb8c,
        0xba991c1bb3a5bb1c,
        0x9ad4d197ba991c1b,
        0xb7538cf69ad4d197,
        0x559ecc0bb7538cf6,
        0x2df37aaf559ecc0b,
        0x721b9b4c2df37aaf,
        0x906cce55721b9b4c,
        0xccd1ac27906cce55,
        0x811429e4ccd1ac27,
        0x9bbb3172811429e4,
    ];

    let mut r0 = 0xaaee;
    let mut r1 = 0xaa66;
    let mut r2 = 0xaaee;
    let mut r3 = 0xaa66;
    let mut key_block = 0xabcdef0123456789;

    let mut blocks = vec![];

    for r in 0..crypt::NUM_ROUNDS {
        let subkeys = subkey_gen::generate_subkeys_for_encrypt(&mut key_block, r);
            let (f0, f1) = crypt::f(r0, r1, &subkeys, r);
            if r == 0 {
                assert!(f0 == 0x3eb1);
                assert!(f1 == 0xa4e9);
            }
            let temp_r2 = r2;
            let temp_r3 = r3;
            r2 = r0;
            r3 = r1;
            r0 = temp_r2 ^ f0 as u16;
            r1 = temp_r3 ^ f1 as u16;

            let block = convert_types::to_u32_vec(&vec![r0, r1, r2, r3]);
            let block = ((block[0] as u64) << 32) | block[1] as u64;
            blocks.push(block);
    }

    assert!(blocks == expected);
}

#[test]
fn test_output_whitening() {
    let key: Vec<u8> = vec![0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89];

    let r0 = 0x9bbb;
    let r1 = 0x3172;
    let r2 = 0x8114;
    let r3 = 0x29e4;

    let y = vec![r2, r3, r0, r1];

    let ciphertext = whiten::whiten_output(&whiten::create_whitening_blocks(&key), &y);

    assert!(ciphertext == 0x2ad9c6e5b8fe56fb);
}

#[test]
fn test_encrypt() {
    let key: Vec<u8> = vec![0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89];
    let plaintext: Vec<u8> = vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

    let ciphertext = crypt::encrypt(&key, &plaintext);

    assert!(ciphertext == 0x2ad9c6e5b8fe56fb);
}

#[test]
fn test_decrypt() {
    let key: Vec<u8> = vec![0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89];
    let ciphertext: Vec<u8> = vec![0x2a, 0xd9, 0xc6, 0xe5, 0xb8, 0xfe, 0x56, 0xfb];

    let plaintext = crypt::decrypt(&key, &ciphertext);

    assert!(plaintext == 0x01234567890abcdef);
}

#[test]
fn test_file_handling() {
    let mut f = File::open("input/plaintext.txt").expect("File for plaintext not found");
    let mut plaintext = String::new();
    f.read_to_string(&mut plaintext).expect("Issue parsing the file");
    let plaintext = plaintext.into_bytes();

    let mut f = File::open("input/key.txt").expect("File for key not found");
    let mut key = String::new();
    f.read_to_string(&mut key).expect("Issue parsing the file");
    let key = key.into_bytes();

    // let key: Vec<u8> = vec![0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89];
    // let plaintext: Vec<u8> = vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];

    let ciphertext = crypt::encrypt(&key, &plaintext);
    println!("{:x}", ciphertext);
}
